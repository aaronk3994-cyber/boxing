<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitBlock Puzzle - Pro</title>
    <style>
        :root {
            --bg: #0d1117;
            --grid-bg: #161b22;
            --border: #30363d;
            --accent: #238636;
            --text: #c9d1d9;
            --ghost: rgba(35, 134, 54, 0.2);
        }
        body { 
            background: var(--bg); 
            color: var(--text); 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            height: 100vh; 
            margin: 0; 
            overflow: hidden;
            user-select: none;
        }
        #game-container { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        .stats { display: flex; gap: 40px; font-size: 18px; font-weight: 600; color: #8b949e; }
        #best-score { color: #f2cc60; }
        #grid { 
            display: grid; 
            grid-template-columns: repeat(10, 32px); 
            grid-template-rows: repeat(10, 32px); 
            gap: 4px; 
            background: var(--border); 
            padding: 8px; 
            border-radius: 6px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .cell { width: 32px; height: 32px; background: var(--grid-bg); border-radius: 3px; }
        .cell.filled { background: var(--accent); border: 1px solid #2ea043; box-shadow: inset 0 0 5px rgba(0,0,0,0.2); }
        #hand { display: flex; gap: 20px; align-items: center; justify-content: center; min-height: 130px; margin-top: 15px; }
        .piece { display: grid; gap: 3px; cursor: grab; padding: 10px; border: 1px solid transparent; border-radius: 4px; }
        .piece:hover { background: #21262d; border-color: #30363d; }
        .piece-cell { width: 20px; height: 20px; background: var(--accent); border-radius: 2px; }
        
        button {
            background-color: #21262d;
            color: #58a6ff;
            border: 1px solid rgba(240,246,252,0.1);
            padding: 10px 20px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }
        button:hover { background-color: #30363d; border-color: #8b949e; transform: translateY(-1px); }
        
        #overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.9);
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div class="stats">
            <div>Score: <span id="current-score">0</span></div>
            <div>Best: <span id="best-score">0</span></div>
        </div>
        <div id="grid"></div>
        <div id="hand"></div>
        <button onclick="resetGame()">Manual Restart</button>
    </div>

    <div id="overlay">
        <h1 style="color: #f85149; font-size: 48px; margin-bottom: 10px;">GAME OVER</h1>
        <p id="final-stats" style="font-size: 20px; margin-bottom: 30px; text-align: center;"></p>
        <button onclick="resetGame()" style="background: var(--accent); color: white; padding: 15px 40px; font-size: 18px;">Respawn Now</button>
    </div>

    <script>
        const gridElement = document.getElementById('grid');
        const handElement = document.getElementById('hand');
        const scoreElement = document.getElementById('current-score');
        const bestElement = document.getElementById('best-score');
        const overlay = document.getElementById('overlay');
        const finalStats = document.getElementById('final-stats');
        
        let score = 0;
        let bestScore = localStorage.getItem('blockBlastBest') || 0;
        let grid = [];
        let currentHandShapes = [];

        bestElement.innerText = bestScore;

        const shapes = [
            {data: [[0,0], [0,1], [1,0], [1,1]], name: 'Square'},
            {data: [[0,0], [0,1], [0,2]], name: 'Line3H'},
            {data: [[0,0], [1,0], [2,0]], name: 'Line3V'},
            {data: [[0,0], [0,1], [0,2], [0,3]], name: 'Line4H'},
            {data: [[0,0], [1,0], [2,0], [3,0]], name: 'Line4V'},
            {data: [[0,0], [1,0], [1,1]], name: 'LSmall'},
            {data: [[0,0], [1,0], [2,0], [2,1]], name: 'LBig'},
            {data: [[0,0], [0,1], [1,1], [2,1]], name: 'JBig'},
            {data: [[0,0]], name: 'Dot'}
        ];

        function resetGame() {
            score = 0;
            scoreElement.innerText = '0';
            overlay.style.display = 'none';
            grid = Array(10).fill().map(() => Array(10).fill(0));
            initGridUI();
            spawnPieces();
        }

        function initGridUI() {
            gridElement.innerHTML = '';
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 10; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.addEventListener('dragover', e => e.preventDefault());
                    cell.addEventListener('drop', handleDrop);
                    gridElement.appendChild(cell);
                }
            }
        }

        function spawnPieces() {
            handElement.innerHTML = '';
            currentHandShapes = [];
            for (let i = 0; i < 3; i++) {
                const shapeObj = shapes[Math.floor(Math.random() * shapes.length)];
                currentHandShapes.push(shapeObj.data);
                createPieceUI(shapeObj.data, i);
            }
            if (!canAnyPieceFit()) triggerGameOver();
        }

        function createPieceUI(shape, index) {
            const piece = document.createElement('div');
            piece.className = 'piece';
            piece.draggable = true;
            piece.dataset.index = index;
            
            const maxR = Math.max(...shape.map(p => p[0]));
            const maxC = Math.max(...shape.map(p => p[1]));
            piece.style.gridTemplateRows = `repeat(${maxR + 1}, 20px)`;
            piece.style.gridTemplateColumns = `repeat(${maxC + 1}, 20px)`;

            shape.forEach(p => {
                const pc = document.createElement('div');
                pc.className = 'piece-cell';
                pc.style.gridRowStart = p[0] + 1;
                pc.style.gridColumnStart = p[1] + 1;
                piece.appendChild(pc);
            });

            piece.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('shapeData', JSON.stringify(shape));
                e.dataTransfer.setData('handIndex', index);
                piece.classList.add('dragging');
            });
            piece.addEventListener('dragend', () => piece.classList.remove('dragging'));
            
            handElement.appendChild(piece);
        }

        function handleDrop(e) {
            const r = parseInt(e.target.dataset.r);
            const c = parseInt(e.target.dataset.c);
            const shape = JSON.parse(e.dataTransfer.getData('shapeData'));
            const handIndex = e.dataTransfer.getData('handIndex');

            if (canPlace(shape, r, c)) {
                placeShape(shape, r, c);
                checkLines();
                
                // Remove from internal hand tracker
                const pieceEl = document.querySelector(`.piece[data-index="${handIndex}"]`);
                if(pieceEl) pieceEl.remove();
                
                // Mark this shape as "gone" (null) in currentHandShapes
                currentHandShapes[handIndex] = null;

                if (currentHandShapes.every(s => s === null)) {
                    spawnPieces();
                } else {
                    if (!canAnyPieceFit()) triggerGameOver();
                }
            }
        }

        function canPlace(shape, r, c) {
            return shape.every(([dr, dc]) => {
                const nr = r + dr, nc = c + dc;
                return nr >= 0 && nr < 10 && nc >= 0 && nc < 10 && grid[nr][nc] === 0;
            });
        }

        function placeShape(shape, r, c) {
            shape.forEach(([dr, dc]) => {
                grid[r + dr][c + dc] = 1;
                const index = (r + dr) * 10 + (c + dc);
                gridElement.children[index].classList.add('filled');
            });
            score += shape.length * 10;
            updateScoreUI();
        }

        function checkLines() {
            let rowsToClear = [];
            let colsToClear = [];

            for (let i = 0; i < 10; i++) {
                if (grid[i].every(val => val === 1)) rowsToClear.push(i);
                if (grid.map(row => row[i]).every(val => val === 1)) colsToClear.push(i);
            }

            rowsToClear.forEach(r => {
                grid[r] = Array(10).fill(0);
                for (let c = 0; c < 10; c++) gridElement.children[r * 10 + c].classList.remove('filled');
            });

            colsToClear.forEach(c => {
                for (let r = 0; r < 10; r++) {
                    grid[r][c] = 0;
                    gridElement.children[r * 10 + c].classList.remove('filled');
                }
            });

            if (rowsToClear.length > 0 || colsToClear.length > 0) {
                const combo = rowsToClear.length + colsToClear.length;
                score += combo * 150;
                updateScoreUI();
            }
        }

        function canAnyPieceFit() {
            // Check only pieces that haven't been placed yet
            return currentHandShapes.some(shape => {
                if (!shape) return false; 
                for (let r = 0; r < 10; r++) {
                    for (let c = 0; c < 10; c++) {
                        if (canPlace(shape, r, c)) return true;
                    }
                }
                return false;
            });
        }

        function updateScoreUI() {
            scoreElement.innerText = score;
            if (score > bestScore) {
                bestScore = score;
                bestElement.innerText = bestScore;
                localStorage.setItem('blockBlastBest', bestScore);
            }
        }

        function triggerGameOver() {
            finalStats.innerHTML = `Final Score: ${score}<br>Your Best: ${bestScore}`;
            overlay.style.display = 'flex';
        }

        resetGame();
    </script>
</body>
</html>
